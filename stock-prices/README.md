# 📈 프로그래머스 '주식가격' 문제 풀이

> 문제 링크: [https://school.programmers.co.kr/learn/courses/30/lessons/42584](https://school.programmers.co.kr/learn/courses/30/lessons/42584)

## 🎯 문제 해결 전략

이 문제는 각 시점의 주식 가격이 떨어지지 않고 얼마나 유지되었는지를 계산하는 문제입니다. 처음에는 단순한 이중 반복문으로 접근했지만, 효율성 테스트에서 시간 초과가 발생할 것을 예상하고 **스택(Stack)** 자료구조를 활용하여 O(N) 시간 복잡도로 해결했습니다.

핵심 아이디어는 다음과 같습니다.

1.  아직 가격이 하락하지 않은 시점의 **인덱스**를 스택에 저장합니다.
2.  가격을 순회하다가 현재 가격이 스택의 최상단 인덱스에 해당하는 가격보다 작아지는 '하락 시점'을 만납니다.
3.  이때 스택에서 인덱스를 꺼내, 현재 시점과의 차이를 계산하여 '가격이 유지된 기간'을 구합니다.
4.  값을 직접 저장하는 대신 **인덱스**를 저장함으로써, 가격 정보(`prices[index]`)와 시점 정보(`index`)를 모두 활용하여 기간을 효율적으로 계산할 수 있었습니다.

## 💻 핵심 코드

```python
def solution(prices):
    # 각 가격들의 기간을 담을 배열
    answer = [0] * len(prices)
    # 각 가격들의 인덱스를 저장할 스택
    # 기간 = (이후 처음으로 떨어진 가격의 인덱스 또는 최대) - (해당 가격의 인덱스)
    st = []

    # 각 가격을 인덱스와 함께 순회
    for i, price in enumerate(prices):
        # 스택엔 뭔가 있고, 가격이 떨어졌으면(가장 '최신'의 가격과 비교, 스택 특)
        while st and price < prices[st[-1]]:
            # 맨위에 있던 가격의 인덱스를 pop
            top_idx = st.pop()
            # 계산해서 결과에 넣어버려
            answer[top_idx] = i - top_idx
        # 현재 인덱스를 스택에 추가 (미래의 가격 하락을 기다림)
        st.append(i)

    # 아직까지 남아있다? 계속해서 가격이 떨어지지 않음 처리
    while st:
        top_idx = st.pop()
        answer[top_idx] = len(prices) - 1 - top_idx

    return answer
```

## 🤔 배운 점 (Takeaway)

이번 문제를 통해 스택 자료구조를 활용하여 시간 복잡도를 O(N²)에서 O(N)으로 개선하는 방법을 익혔습니다. 특히 문제에서 요구하는 결과(기간)를 얻기 위해 값 자체가 아닌 **인덱스**를 스택에 저장하는 것이 왜 중요한지 명확하게 이해할 수 있었습니다.